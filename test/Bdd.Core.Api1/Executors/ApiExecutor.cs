// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ApiExecutor.cs" company="Microsoft">
//   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
//   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//   OTHER DEALINGS IN THE SOFTWARE.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------
// <auto-generated>

namespace Bdd.Core.Api.Executors
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Configuration;
    using System.IO;
    using System.Linq;
    using System.Net.Http;
    using System.Security.Cryptography.X509Certificates;
    using System.Threading.Tasks;

    using Bdd.Core.Entities;
    using Bdd.Core.Executors;
    using Bdd.Core.Utils;

    using Flurl.Http;
    using Flurl.Http.Content;

    using NLog;

    using Utils;

    public class ApiExecutor
    {
        // public static Func<AzureAdBase, Task<string>> AuthTokenCallback { get; set; }

        protected static readonly Logger Logger = LogManager.GetCurrentClassLogger();

        private readonly ConcurrentDictionary<string, AuthInfo> authTokens = new ConcurrentDictionary<string, AuthInfo>(StringComparer.OrdinalIgnoreCase);

        public Task GetResponseAsync(string url)
        {
            throw new NotImplementedException();
        }

        //private readonly string[] perfAppWithArgs = ConfigurationManager.AppSettings["PerfExecutor"].Split(new[] { ' ' }, 2);

        //private readonly ConsoleExecutor perfExecutor = new ConsoleExecutor();

        //public async Task<bool> RunPerf(string url, Credentials userDetails, Guid correlationId = default(Guid))
        //{
        //    AuthInfo authInfo = this.GetAuthInfo(userDetails);
        //    var uri = new Uri(url);
        //    var appName = uri.Host;
        //    var exe = perfAppWithArgs.FirstOrDefault();
        //    var logFileName = $"{exe}_{appName}_{DateTime.Now.ToString("dd_MMM_yy_hh_mm_ss_tt")}".Replace("-", "_").Replace(".", "_");
        //    var args = perfAppWithArgs.LastOrDefault();
        //    var leftPart = uri.GetLeftPart(UriPartial.Authority);
        //    var formattedArgs = string.Format(args, appName, logFileName, uri.OriginalString, leftPart, Path.GetDirectoryName(new Uri(GenericExtensions.TestAssembly.CodeBase).LocalPath));

        //    // TODO: Fine for now, but have a better way to handle different perf-tools instead of hard-coding this way
        //    if (exe.Equals("locust", StringComparison.OrdinalIgnoreCase))
        //    {
        //        var locustFile = "locustfile.py";
        //        string text = File.ReadAllText(locustFile.GetFullPath());
        //        text = text.Replace("ROUTE", uri.OriginalString.Replace(leftPart, string.Empty)).Replace("AUTH_TOKEN", authInfo?.AuthToken).Replace("BUSINESS_CONTEXT", string.Empty); // authInfo.BusinessContext
        //        File.WriteAllText(($"{logFileName}.py").GetFullPath(), text);

        //        // Launch locust UI when available
        //        if (!args.Contains("--no-web"))
        //        {
        //            Logger.Info("LAUNCH LOCUST WEB UI: http://localhost:8089/");
        //            ////var process = new Process();
        //            ////process.StartInfo = new ProcessStartInfo
        //            ////{
        //            ////    UseShellExecute = true,
        //            ////    FileName = "http://localhost:8089/"
        //            ////};
        //            ////process.Start(); // TODO: process.WaitForExit();
        //        }
        //    }
        //    else // e.g. Apache-bench
        //    {
        //        formattedArgs = formattedArgs.Replace("AUTH_TOKEN", authInfo?.AuthToken).Replace("BUSINESS_CONTEXT", string.Empty); // authInfo.BusinessContext.Replace("\"", "\\\"")
        //    }

        //    return await this.perfExecutor.Run(exe, formattedArgs).ConfigureAwait(false);
        //}

        public async Task<string> DownloadAsync(string url, string localFolderPath, string localFileName = null)
        {
            var result = await url.DownloadFileAsync(localFolderPath, localFileName).ConfigureAwait(false);
            return result;
        }

        public Task<T> GetAsync<T>(string url, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null)
        {
            AuthInfo authInfo = this.GetAuthInfo(userDetails);
            var result = this.GetAsync<T>(url.WithOAuthBearerToken(authInfo?.AuthToken), correlationId, additionalHeaders);
            return result;
        }

        public Task<HttpResponseMessage> GetResponseAsync(string url, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null)
        {
            AuthInfo authInfo = this.GetAuthInfo(userDetails);
            var result = this.GetResponseAsync(url.WithOAuthBearerToken(authInfo?.AuthToken), correlationId, additionalHeaders);
            return result;
        }

        public Task<AuthInfo> AddAuthInfo(Credentials userDetails, bool graphApi = false)
        {
            return Task.FromResult(this.authTokens.GetOrAdd(GetKey(userDetails), k => new AuthInfo { AuthToken = this.GetToken(userDetails, graphApi).GetAwaiter().GetResult() }));
        }

        public AuthInfo GetAuthInfo(Credentials userDetails)
        {
            if (this.authTokens.TryGetValue(GetKey(userDetails), out var value))
            {
                return value;
            }

            Logger.Warn($"AuthToken unavailable: {userDetails.Role} - {userDetails.User}");
            return null;
        }

        public async Task<T> PostAsync<T>(string url, object content, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null, bool isXml = false)
        {
            AuthInfo authInfo = this.GetAuthInfo(userDetails);
            var result = await url.ProcessAsync<T>(HttpMethod.Post, content, authInfo?.AuthToken, correlationId, additionalHeaders, isXml).ConfigureAwait(false);
            return result;
        }

        public async Task<HttpResponseMessage> PostWithResponseAsync(string url, object content, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null, bool isXml = false)
        {
            AuthInfo authInfo = this.GetAuthInfo(userDetails);
            var result = await url.ProcessResponseAsync(HttpMethod.Post, content, authInfo?.AuthToken, correlationId, additionalHeaders, isXml).ConfigureAwait(false);
            return result;
        }

        public async Task<T> PostAsync<T>(string url, object content, X509Certificate2 cert, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null, bool isXml = false)
        {
            var result = await url.ProcessAsync<T>(HttpMethod.Post, content, cert, correlationId, additionalHeaders, isXml).ConfigureAwait(false);
            return result;
        }

        public async Task<HttpResponseMessage> PostWithResponseAsync(string url, object content, X509Certificate2 cert, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null, bool isXml = false)
        {
            var result = await url.ProcessResponseAsync(HttpMethod.Post, content, cert, correlationId, additionalHeaders, isXml).ConfigureAwait(false);
            return result;
        }

        public async Task<HttpResponseMessage> PostMultipartAsync(string url, Action<CapturedMultipartContent> buildContent, X509Certificate2 cert, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null)
        {
            var result = await url.ProcessMultipartPostResponseAsync(buildContent, cert, correlationId, additionalHeaders).ConfigureAwait(false);
            return result;
        }

        public async Task<HttpResponseMessage> PostMultipartAsync(string url, Action<CapturedMultipartContent> buildContent, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null)
        {
            var result = await url.ProcessMultipartPostResponseAsync(buildContent, userDetails.User, userDetails.Password, correlationId, additionalHeaders).ConfigureAwait(false);
            return result;
        }

        public async Task<T> PutAsync<T>(string url, object content, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null, bool isXml = false)
        {
            AuthInfo authInfo = this.GetAuthInfo(userDetails);
            var result = await url.ProcessAsync<T>(HttpMethod.Put, content, authInfo?.AuthToken, correlationId, additionalHeaders, isXml).ConfigureAwait(false);
            return result;
        }

        public async Task<HttpResponseMessage> PutWithResponseAsync(string url, object content, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null, bool isXml = false)
        {
            AuthInfo authInfo = this.GetAuthInfo(userDetails);
            var result = await url.ProcessResponseAsync(HttpMethod.Put, content, authInfo?.AuthToken, correlationId, additionalHeaders, isXml).ConfigureAwait(false);
            return result;
        }

        public async Task<T> PutAsync<T>(string url, object content, X509Certificate cert, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null, bool isXml = false)
        {
            var result = await url.ProcessAsync<T>(HttpMethod.Put, content, cert, correlationId, additionalHeaders, isXml).ConfigureAwait(false);
            return result;
        }

        public async Task<HttpResponseMessage> PutWithResponseAsync(string url, object content, X509Certificate cert, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null, bool isXml = false)
        {
            var result = await url.ProcessResponseAsync(HttpMethod.Put, content, cert, correlationId, additionalHeaders, isXml).ConfigureAwait(false);
            return result;
        }

        public async Task<T> PatchAsync<T>(string url, object content, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null, bool isXml = false)
        {
            AuthInfo authInfo = this.GetAuthInfo(userDetails);
            var result = await url.ProcessAsync<T>(new HttpMethod("PATCH"), content, authInfo?.AuthToken, correlationId, additionalHeaders, isXml).ConfigureAwait(false);
            return result;
        }

        public async Task<HttpResponseMessage> PatchWithResponseAsync<T>(string url, object content, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null, bool isXml = false)
        {
            AuthInfo authInfo = this.GetAuthInfo(userDetails);
            var result = await url.ProcessResponseAsync(new HttpMethod("PATCH"), content, authInfo?.AuthToken, correlationId, additionalHeaders, isXml).ConfigureAwait(false);
            return result;
        }

        private static string GetKey(Credentials userDetails)
        {
            return string.IsNullOrWhiteSpace(userDetails.SecretKey) ? $"{userDetails.Role}.{userDetails.User}" : userDetails.SecretKey;
        }

        public Task<HttpResponseMessage> DeleteWithResponseAsync(string url, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null)
        {
            AuthInfo authInfo = this.GetAuthInfo(userDetails);
            return this.DeleteWithResponseAsync(url.WithOAuthBearerToken(authInfo?.AuthToken), correlationId, additionalHeaders);
        }

        public async Task<bool> DeleteAsync(string url, Credentials userDetails, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null)
        {
            return (await this.DeleteWithResponseAsync(url, userDetails, correlationId, additionalHeaders).ConfigureAwait(false)).IsSuccessStatusCode;

        }

        public async Task<HttpResponseMessage> DeleteWithResponseAsync(IFlurlRequest request, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null)
        {
            if (additionalHeaders != null)
            {
                request = request.WithHeaders(additionalHeaders);
            }

            var result = await request
                    .WithHeader(HttpHeaders.RequestIdKey, correlationId)
                    .DeleteAsync()
                    .ConfigureAwait(false);

            if (!result.IsSuccessStatusCode)
            {
                Logger.Warn($"{result.StatusCode}: {result.ReasonPhrase}");
            }

            return result;
        }

        private async Task<bool> DeleteAsync(IFlurlRequest request, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null)
        {
            return (await this.DeleteWithResponseAsync(request, correlationId, additionalHeaders).ConfigureAwait(false)).IsSuccessStatusCode;
        }

        private async Task<HttpResponseMessage> GetResponseAsync(IFlurlRequest request, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null)
        {
            if (additionalHeaders != null)
            {
                request = request.WithHeaders(additionalHeaders);
            }

            var response = await request
                    .WithHeader(HttpHeaders.RequestIdKey, correlationId)
                    .GetAsync()
                    .ConfigureAwait(false);

            var result = await response.EnsureSuccessAsync().ConfigureAwait(false);
            return result;
        }

        private async Task<T> GetAsync<T>(IFlurlRequest request, Guid correlationId = default(Guid), Dictionary<string, object> additionalHeaders = null)
        {
            var result = await this.GetResponseAsync(request, correlationId, additionalHeaders).ConfigureAwait(false);
            return await result.Content.ReadAsJsonAsync<T>().ConfigureAwait(false);
        }

        public virtual async Task<string> GetToken(Credentials credentials, bool graphApi = false)
        {
            if (!string.IsNullOrWhiteSpace(credentials.SecretKey))
            {
                var azureAdBase = graphApi ? new AzureAdBase(nameof(graphApi)) : new AzureAdBase();
                var token = await azureAdBase.GetOAuthTokenAsync(credentials.SecretKey).ConfigureAwait(false);
                return token;
            }

            return null;
        }
    }
}